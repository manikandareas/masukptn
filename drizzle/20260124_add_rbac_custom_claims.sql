-- ============================================================
-- RBAC Migration: User and Admin Roles with Auth Hook
-- Based on Supabase Custom Claims documentation
-- Reference: https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac
-- ============================================================

-- 1. Create role enum (simplified: user and admin only)
CREATE TYPE public.app_role AS ENUM ('user', 'admin');

-- 2. Create user_roles table
CREATE TABLE public.user_roles (
  id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id   UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role      app_role NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user_id)
);

ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- 3. Create custom access token hook
-- This adds user_role to the JWT claims
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
  DECLARE
    claims jsonb;
    user_role public.app_role;
  BEGIN
    -- Fetch the user role from user_roles table
    SELECT role INTO user_role 
    FROM public.user_roles 
    WHERE user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    IF user_role IS NOT NULL THEN
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    ELSE
      -- Default to 'user' role if not set
      claims := jsonb_set(claims, '{user_role}', '"user"');
    END IF;

    event := jsonb_set(event, '{claims}', claims);
    RETURN event;
  END;
$$;

-- 4. Grant permissions to auth hook (REQUIRED)
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;

GRANT EXECUTE
  ON FUNCTION public.custom_access_token_hook
  TO supabase_auth_admin;

REVOKE EXECUTE
  ON FUNCTION public.custom_access_token_hook
  FROM authenticated, anon, public;

GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;

REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;

-- 5. RLS policies for user_roles table
CREATE POLICY "Auth admin can read user roles" 
ON public.user_roles
FOR SELECT
TO supabase_auth_admin
USING (true);

CREATE POLICY "Users can view their own role" 
ON public.user_roles
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Admins can manage all user roles" 
ON public.user_roles
FOR ALL
TO authenticated
USING ((SELECT auth.jwt() ->> 'user_role') = 'admin')
WITH CHECK ((SELECT auth.jwt() ->> 'user_role') = 'admin');

-- 6. Function to auto-assign 'user' role on signup
CREATE OR REPLACE FUNCTION public.handle_new_user_role()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.user_roles (user_id, role)
  VALUES (NEW.id, 'user');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. Trigger for auto-assignment
CREATE TRIGGER on_auth_user_created_role
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user_role();

-- 8. Helper function to check admin role in RLS
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN (SELECT auth.jwt() ->> 'user_role') = 'admin';
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';

-- 9. RLS policies for questions table (admin only for mutations)
CREATE POLICY "Anyone can read published questions" 
ON public.questions
FOR SELECT
TO authenticated
USING (status = 'published' OR (SELECT public.is_admin()));

CREATE POLICY "Admins can insert questions" 
ON public.questions
FOR INSERT
TO authenticated
WITH CHECK ((SELECT public.is_admin()));

CREATE POLICY "Admins can update questions" 
ON public.questions
FOR UPDATE
TO authenticated
USING ((SELECT public.is_admin()))
WITH CHECK ((SELECT public.is_admin()));

CREATE POLICY "Admins can delete questions" 
ON public.questions
FOR DELETE
TO authenticated
USING ((SELECT public.is_admin()));

-- 10. RLS policies for question_sets table
CREATE POLICY "Anyone can read published question_sets" 
ON public.question_sets
FOR SELECT
TO authenticated
USING (status = 'published' OR (SELECT public.is_admin()));

CREATE POLICY "Admins can insert question_sets" 
ON public.question_sets
FOR INSERT
TO authenticated
WITH CHECK ((SELECT public.is_admin()));

CREATE POLICY "Admins can update question_sets" 
ON public.question_sets
FOR UPDATE
TO authenticated
USING ((SELECT public.is_admin()))
WITH CHECK ((SELECT public.is_admin()));

CREATE POLICY "Admins can delete question_sets" 
ON public.question_sets
FOR DELETE
TO authenticated
USING ((SELECT public.is_admin()));

-- 11. RLS policies for question_set_items table
CREATE POLICY "Anyone can read question_set_items for published sets"
ON public.question_set_items
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM public.question_sets 
    WHERE id = question_set_id 
    AND (status = 'published' OR (SELECT public.is_admin()))
  )
);

CREATE POLICY "Admins can manage question_set_items" 
ON public.question_set_items
FOR ALL
TO authenticated
USING ((SELECT public.is_admin()))
WITH CHECK ((SELECT public.is_admin()));
